<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>PrincessBrideChat</title>
<script src="https://cdn.jsdelivr.net/npm/gun/gun.js"></script>
<script src="https://cdn.jsdelivr.net/npm/gun/sea.js"></script>
<style>
  body { font-family: Arial; background: #f0f0f0; margin: 0; padding: 20px; }
  #chat { max-width: 500px; margin: auto; }
  #messages { border: 1px solid #ccc; padding: 10px; height: 300px; overflow-y: scroll; background: #fff; }
  #messages div { margin-bottom: 10px; }
  #input { display: flex; margin-top: 10px; }
  #input input { flex: 1; padding: 10px; font-size: 16px; }
  #input button { padding: 10px 20px; font-size: 16px; }
  #login { text-align: center; margin-bottom: 20px; }
  #login input { padding: 5px; margin: 5px; }
    .autocomplete { position: relative; display: inline-block; width: 300px; }
  input { width: 100%; padding: 8px; box-sizing: border-box; }
  .autocomplete-items {
    position: absolute;
    border: 1px solid #ccc;
    border-bottom: none;
    z-index: 99;
    bottom: 100%;
    left: 0; right: 0;
    background: white;
    max-height: 150px;
    overflow-y: auto;
  }
  .autocomplete-item {
    padding: 8px;
    cursor: pointer;
  }
  .autocomplete-item:hover, .autocomplete-active {
    background-color: #e9e9e9;
  }
</style>
</head>
<body>

<div id="chat">
  <h2>Gun.js Chat with Auth</h2>

  <div id="login">
    <input id="username" placeholder="Username" />
    <input id="password" type="password" placeholder="Password" />
    <button id="signupBtn">Sign Up</button>
    <button id="loginBtn">Login</button>
  </div>

  <div id="chatControls" style="display:block; margin-bottom:10px;">
    <input id="chatName" placeholder="New chat name (e.g. lobby)" style="width:60%; padding:8px;" />
    <button id="joinBtn">Join</button>
    <select id="chatSelect" style="width:38%; padding:8px;"></select>
    <div style="margin-top:8px; display:flex; gap:8px; align-items:center;">
      <input id="shareUrl" readonly style="flex:1; padding:8px;" />
      <button id="copyBtn">Copy URL</button>
    </div>
  </div>

  <div id="messages"></div>

  <div id="input" style="display:none;">
    <div class="autocomplete">
        <input id="msgInput" type="text" placeholder="Type something...">
    </div>
    <button id="sendBtn">Send</button><hr>
    <div>
      <input type="checkbox" id="box" checked>
      <label for="box">Enable sound notifications</label></div>
</div>
</div>

<script>

  var audio = new Audio('/assets/notification.mp3');
  audio.volume = 0.6;
  // Attempt to unlock audio on first user interaction to satisfy autoplay policies


// Connect to global Gun relay server
var gun = Gun({peers: ['https://gun.o8.is/gun', 'https://gun.octalmage.com/gun']})

const users = gun.get('users');
let messages = null; // will point to current chat messages node

// read chat from URL or default
function getChatFromUrl() {
  try {
    const params = new URLSearchParams(window.location.search);
    return params.get('chat') || 'mainlobby';
  } catch (e) { return 'mainlobby'; }
}

let currentChat = 'pr-inces-sbride-'+getChatFromUrl();

let old;

const loginDiv = document.getElementById('login');
const inputDiv = document.getElementById('input');
const messagesDiv = document.getElementById('messages');
const usernameInput = document.getElementById('username');
const passwordInput = document.getElementById('password');
const signupBtn = document.getElementById('signupBtn');
const loginBtn = document.getElementById('loginBtn');
const msgInput = document.getElementById('msgInput');
const sendBtn = document.getElementById('sendBtn');
const chatNameInput = document.getElementById('chatName');
const joinBtn = document.getElementById('joinBtn');
const chatSelect = document.getElementById('chatSelect');
const shareUrlInput = document.getElementById('shareUrl');
const copyBtn = document.getElementById('copyBtn');
const checkbox= document.getElementById('box');

let lastMessage;
let currentUser;
let prevMessages = null;
let currentListener = null;
let renderedKeys = new Set();
let currentAlias = null;

const input = msgInput;
let currentFocus = -1;
let dataList = [];

fetch('quotes.json')
    .then(response => response.json())
    .then(data => {
        dataList = data.map(item => item.text);
        // if quotes load after messages listener attached, refresh display
        if (messages) {
          loadMessages();
        }
    })
    .catch(error => console.error('Error loading quotes:', error));

checkbox.checked = (localStorage.getItem('notify-sound') !== 'false');

checkbox.addEventListener('change', function() {
  localStorage.setItem('notify-sound', this.checked ? 'true' : 'false');
});

msgInput.addEventListener("input", function() {
  const value = this.value;
  closeAllLists();
  currentFocus = -1;
  if (!value) return false;

  const list = document.createElement("div");
  list.setAttribute("class", "autocomplete-items");
  this.parentNode.appendChild(list);

  dataList.forEach(item => {
    if (item.toLowerCase().startsWith(value.toLowerCase())) {
      const itemDiv = document.createElement("div");
      itemDiv.innerHTML = "<strong>" + item.substr(0, value.length) + "</strong>" + item.substr(value.length);
      itemDiv.classList.add("autocomplete-item");
      itemDiv.addEventListener("click", function() {
        input.value = item;
        closeAllLists();
      });
      list.appendChild(itemDiv);
    }
  });
});

input.addEventListener("keydown", function(e) {
  let items = document.querySelectorAll(".autocomplete-item");
  if (!items) return;

  if (e.key === "ArrowDown") {
    // move down
    currentFocus++;
    addActive(items);
    e.preventDefault();
  } else if (e.key === "ArrowUp") {
    // move up
    currentFocus--;
    addActive(items);
    e.preventDefault();
  } else if (e.key === "Enter") {
    e.preventDefault();
    if (currentFocus > -1) {
      if (items[currentFocus]) items[currentFocus].click();
    } else sendBtn.click();
  } else if (e.key === "Tab") {
    // tab selects first item if available
    if (items.length > 0) {
      input.value = items[0].innerText;
      closeAllLists();
      e.preventDefault();
    }else{
        input.value=input.placeholder;
        closeAllLists();
    }
  }
});

function addActive(items) {
  if (!items) return false;
  removeActive(items);
  if (currentFocus >= items.length) currentFocus = 0;
  if (currentFocus < 0) currentFocus = items.length - 1;
  items[currentFocus].classList.add("autocomplete-active");
}
function scrollToLastMessage() {
    messagesDiv.scrollTop = messagesDiv.scrollHeight;
}


// Helper: update share URL input
function updateShareUrl(chat) {
  const url = new URL(window.location.href);
  url.searchParams.set('chat', chat);
  shareUrlInput.value = url.toString();
}

// Switch to a chat: detach old listeners, attach to new messages node
function setChat(chatId) {
  if (!chatId) chatId = 'mainlobby';
  currentChat = 'pr-inces-sbride-'+chatId;
  if (messages) {
    try { messages.map().off(); } catch (e) {}
  }
  messages = gun.get('chat-' + chatId).get('messages');
  loadMessages();
  updateShareUrl(chatId);
  // update URL without reloading
  try { history.replaceState(null, '', '?chat=' + encodeURIComponent(chatId)); } catch (e) {}
}

function removeActive(items) {
  for (let i = 0; i < items.length; i++) {
    items[i].classList.remove("autocomplete-active");
  }
}

function closeAllLists() {
  const items = document.getElementsByClassName("autocomplete-items");
  for (let i = 0; i < items.length; i++) {
    items[i].parentNode.removeChild(items[i]);
  }
  currentFocus = -1;
}

document.addEventListener("click", function(e) {
  closeAllLists();
});


  // Sign up
  signupBtn.addEventListener('click', () => {
    const user = usernameInput.value.trim();
    const pass = passwordInput.value.trim();
    if (!user || !pass) return alert('Enter username & password');

    gun.user().create(user, pass, ack => {
      if (ack.err) return alert('Error: ' + ack.err);
      alert('Account created! Now log in.');
    });
  });

  // Login
  loginBtn.addEventListener('click', () => {
    const user = usernameInput.value.trim();
    const pass = passwordInput.value.trim();
    if (!user || !pass) return alert('Enter username & password');

    gun.user().auth(user, pass, ack => {
      if (ack.err) return alert('Login failed: ' + ack.err);

      currentUser = gun.user();
      // cache alias for suppressing self-notifications
      currentUser.get('alias').once(a => { currentAlias = a; });
      loginDiv.style.display = 'none';
      inputDiv.style.display = 'flex';
      // attach messages listener for the current chat (ensures single listener)
      setChat(currentChat);
    });
  });

  // Send message
  sendBtn.addEventListener('click', () => {
    const text = dataList.indexOf(msgInput.value.trim());
    if (text<0 || !currentUser) {alert('you must only use text from the princess bride movie script to continue'); return};

    // Add username to message
    currentUser.get('alias').once(alias => {
      messages.set({ user: alias || 'Anonymous', text, time: Date.now() });
      msgInput.value = '';
    });
  });

  // Load messages: attach a single listener and clear previous one
  function loadMessages() {
    
    // detach previous listener from previous messages node
    if (prevMessages && currentListener) {
      try { prevMessages.map().off(currentListener); } catch (e) {}
    }
    messagesDiv.innerHTML = '';
    // reset rendered keys for this chat
    renderedKeys = new Set();
    prevMessages = messages;
    currentListener = function(msg) {
      if (!msg) return;
      const key = ((msg.user||'') + '|' + (msg.time||'') + '|' + (msg.text||'')).toString();
      if (renderedKeys.has(key)) return;
      renderedKeys.add(key);
      const div = document.createElement('div');
      const time = msg.time ? new Date(msg.time).toLocaleTimeString() : '';
      // msg.text is intended to be an index into dataList. Parse and lookup safely.
      let displayText = '';
      const idx = parseInt(msg.text, 10);
      if (!isNaN(idx) && dataList && dataList.length > idx) {
        displayText = dataList[idx];
      } else if (typeof msg.text === 'string' && msg.text.length > 0) {
        // fallback: show raw text (index or string)
        displayText = msg.text;
      } else {
        displayText = '[unknown message]';
      }
      div.textContent = `[${time}] ${msg.user}: ${displayText}`;
      messagesDiv.appendChild(div);
      messagesDiv.scrollTop = messagesDiv.scrollHeight;
      lastMessage = msg;
      try {
        const box = document.getElementById('box');
        if (box && box.checked && msg.user && msg.user && old!==lastMessage && msg.user!==currentAlias) {
          old=lastMessage;
          audio.play().then(() => {
            console.log('notification played');
          }).catch(err => {
            console.warn('audio play failed', err);
          });
        }
      } catch(e) { console.warn('notify error', e); }
      // set autocomplete placeholder to next quote if available
      try {
        if (!isNaN(idx) && dataList && dataList.length > (idx+1)) input.placeholder = dataList[idx+1];
      } catch (e) {}
    };
    if (messages && messages.map) messages.map().on(currentListener);
  }
  // Optional: auto-logout after refresh
  gun.user().recall({ sessionStorage: true }, ack => {
    if (!ack.err && ack.sea) {
      currentUser = gun.user();
      // cache alias for suppressing self-notifications
      currentUser.get('alias').once(a => { currentAlias = a; });
      loginDiv.style.display = 'none';
      inputDiv.style.display = 'flex';
      // attach messages listener via setChat to avoid duplicate listeners
      setChat(currentChat);
    }
  });

// Chat list population and join handling
function addChatToSelect(chat) {
  if (!chat) return;
  // avoid duplicate options
  for (let i=0;i<chatSelect.options.length;i++) if (chatSelect.options[i].value===chat) return;
  const opt = document.createElement('option');
  opt.value = chat; opt.text = chat;
  chatSelect.appendChild(opt);
}

// populate chats from Gun
gun.get('chat-list').map().on((v,k) => {
  if (!v) return;
  addChatToSelect(v);
});

// also load from localStorage fallback
try {
  const stored = JSON.parse(localStorage.getItem('known-chats')||'[]');
  stored.forEach(addChatToSelect);
} catch(e){}

joinBtn.addEventListener('click', () => {
  const chat = chatNameInput.value.trim() || currentChat;
  if (!chat) return alert('Enter chat name');
  gun.get('chat-list').set(chat);
  // persist locally for fallback
  try {
    const s = JSON.parse(localStorage.getItem('known-chats')||'[]');
    if (!s.includes(chat)) { s.push(chat); localStorage.setItem('known-chats', JSON.stringify(s)); }
  } catch(e){}
  addChatToSelect(chat);
  setChat(chat);
});

chatSelect.addEventListener('change', () => {
  const chat = chatSelect.value;
  if (chat) setChat(chat);
});

copyBtn.addEventListener('click', async () => {
  try {
    await navigator.clipboard.writeText(shareUrlInput.value);
    alert('Copied URL to clipboard');
  } catch (e) {
    prompt('Copy this URL', shareUrlInput.value);
  }
});

// initialize chat on load
setChat(currentChat);
updateShareUrl(currentChat);

</script>


</body>
</html>
